# 又臭又长的代码讲解

首先从游戏中的几个基本结构出发：

### counter clock

```verilog
/*该结构是游戏中使用最广泛的一个基础部件，用于实现计时，并可以进行一定程度上的自定义*/
module clock (
         input clk,					
    //外部时钟，用于计数
         input rst,					
    //rst为高电平时，计数器中的值被恢复到rst_Target设置的值
    	 input [31:0]rst_Target,
    //计时器的初值
         input auto_rst,
    //若该项选中，则在一次计数结束之后，计数器值自动恢复到rst_Target设置的值，clk_out输出一个脉冲
         output reg clk_out,
    //当计数器计数为0时，输出1，否则为0
         output reg [31:0]counter
    //计数器，放在output的目的是因为在项目中，有地方会需要这个counter的值
       );

always @(posedge clk or posedge rst)
  begin
    if(rst)
      begin
        counter<=rst_Target;
        clk_out<=0;
          //当rst为高电平时，异步重置计数器
      end
    else
      begin
        if(counter>0)
          begin
            counter<=counter-1;
            clk_out<=0;
          end
        else
          begin
            if(auto_rst)
              counter<=rst_Target;
              //如果auto_rst为高电平，则在一次计数后自动将计数器重置为rst_Target的值
            else
              counter<=counter;
            clk_out<=1;
              //计数结束clk_out输出高电平，如果auto_rst为高电平，则可以生成一个tick的脉冲
          end
      end
  end
endmodule
```

### pulse generator

```verilog
/*该结构用于实现当in电平发生变化时，out中输出一个1 tick的高电平脉冲*/
module pulse_reverse#(parameter netnum=10)(
         input clk,
         input [netnum-1:0]in,
         output [netnum-1:0]out
       );
reg [netnum-1:0]in_r1;
reg [netnum-1:0]in_r2;

always@(posedge clk)
  begin
    in_r1<=in;
    in_r2<=in_r1;
  end
assign out=in_r2^in;
endmodule
```

### sram generator

```verilog
/*使用该结构，可以在不使用IP core的情况下，由综合工具自动生成一个地址位宽为ADDR_WIDTH，数据位宽为DATA_WIDTH，深度为DEPTH的BRAM，并从MEMFILE中自动读取所需要的mem文件*/
module sram #(parameter ADDR_WIDTH=8, DATA_WIDTH=8, DEPTH=256, MEMFILE="") (
         input wire i_clk,
         input wire [ADDR_WIDTH-1:0] i_addr,
         input wire i_write,
         input wire [DATA_WIDTH-1:0] i_data,
         output reg [DATA_WIDTH-1:0] o_data
       );

reg [DATA_WIDTH-1:0] memory_array [0:DEPTH-1];

initial
  begin
    if (MEMFILE > 0)
      begin
        $display("Loading memory init file '" + MEMFILE + "' into array.");
        $readmemh(MEMFILE, memory_array);
      end
  end

always @ (posedge i_clk)
  begin
    if(i_write)
      begin
        memory_array[i_addr] <= i_data;
      end
    else
      begin
        o_data <= memory_array[i_addr];
      end
  end
endmodule
```

下面是关于游戏中使用到的外设部分代码：

### keyboard control

```verilog
/*该模块的目的是从PS2接口中读取键盘传送来的信息，并且将得到的信息存入keyreg中，虽然可以用一个多位宽寄存器实现，但是为了可读性，将每个按键的寄存器分别写开，所以看起来有些难看*/
module keyboard(
         input wire clk,
    //PS2_CLK
         input wire data,
    //接受PS2接口传输来的信号
         output [13:0] ctrl_bus 
    //输出的控制线，用于上层模块对游戏的控制
       );
reg [7:0] data_curr;
    //记录当前接口传输的数据
reg [7:0] data_pre;
    //记录接口传输来的前一个数据
reg [7:0] key_correct;
    //如果键位是程序需要的按键，则key_correct被赋值为该按键的编码，否则key_correct=8'h00
reg [3:0] b;
    //计数器
reg flag;
    //在第10位和11位信号中分别为高电平和低电平，标识一次接收完成
reg keyW;
reg keyA;
reg keyS;
reg keyD;
reg keyQ;
reg keyE;
reg keySp;
reg keyI;
reg keyJ;
reg keyK;
reg keyL;
reg keyU;
reg keyO;
reg keyP;
    //按键寄存器
parameter W = 8'h1d,A = 8'h1c,S = 8'h1b,D = 8'h23,Space = 8'h29,I = 8'h43,J = 8'h3b,K = 8'h42,L = 8'h4b,P = 8'h4d, Q = 8'h15,E = 8'h24,U = 8'h3c,O = 8'h44;
    
initial
  begin
    b=4'h1;
    flag=1'b0;
    data_curr=8'h00;
    data_pre=8'h00;
  end

//数据接收部分
always @(negedge clk) //Activating at negative edge of clock from keyboard
  begin
    case(b)
      1:
        ;
      //first bit
      2:
        data_curr[0]<=data;
      3:
        data_curr[1]<=data;
      4:
        data_curr[2]<=data;
      5:
        data_curr[3]<=data;
      6:
        data_curr[4]<=data;
      7:
        data_curr[5]<=data;
      8:
        data_curr[6]<=data;
      9:
        data_curr[7]<=data;
      10:
        flag<=1'b1; //Parity bit
      11:
        flag<=1'b0; //Ending bit
    endcase
    if(b<=10)
      b<=b+1;
    else if(b==11)
      b<=1;
  end
    
    //一次信号接收完成后，判断是否按键是否为有效按键
always @(posedge flag)
  begin
    if((data_curr==W||data_curr==A||data_curr==S ||
        data_curr==D||data_curr==Space||data_curr==I||
        data_curr==J||data_curr==K||data_curr==L||
        data_curr==P||data_curr==Q||data_curr==E||
        data_curr==U||data_curr==O||data_curr==8'hf0))
      key_correct<=data_curr;
    else
      key_correct<=8'h00;
  end

    //在flag下边沿对按键寄存器进行赋值，按键寄存器在键盘按下时被置1，在抬起时被置0
always@(negedge flag)
  begin
    if(key_correct==8'h00)
      ;
    else
      begin
        if(data_pre==8'hf0)
          begin
            case(key_correct)
              W:
                keyW<=0;
              A:
                keyA<=0;
              S:
                keyS<=0;
              D:
                keyD<=0;
              Space:
                keySp<=0;
              I:
                keyI<=0;
              J:
                keyJ<=0;
              K:
                keyK<=0;
              L:
                keyL<=0;
              P:
                keyP<=0;
              Q:
                keyQ<=0;
              E:
                keyE<=0;
              U:
                keyU<=0;
              O:
                keyO<=0;
              default;
            endcase
          end
        else if(key_correct==8'hf0)
          ;
        else
          begin
            case(key_correct)
              W:
                keyW<=1;
              A:
                keyA<=1;
              S:
                keyS<=1;
              D:
                keyD<=1;
              Space:
                keySp<=1;
              I:
                keyI<=1;
              J:
                keyJ<=1;
              K:
                keyK<=1;
              L:
                keyL<=1;
              P:
                keyP<=1;
              Q:
                keyQ<=1;
              E:
                keyE<=1;
              U:
                keyU<=1;
              O:
                keyO<=1;
            endcase
          end
        data_pre<=key_correct;
      end
  end

assign  ctrl_bus={keySp,keyQ,keyE,keyW,keyS,keyA,keyD,keyP,keyU,keyO,keyI,keyK,keyJ,keyL};
    //ctrl_bus由按键寄存器组成
endmodule
```

### VGA diaplay

```verilog
module vga640x480(
         input wire clk,
    //100MHz时钟，用于计数
         input wire clk_vga,
    //25MHz时钟，用于驱动60Hz 640*480屏幕
         input wire rst,
         output wire hs,
    //h消隐信号
         output wire vs,
    //v消隐信号
         output wire active,
    //当在屏幕绘制区域内时输出高电平
         output wire animate,
    //当一帧绘制完成后，发出一个1 tick的脉冲
         output wire [9:0] x,
    //输出当前画笔在屏幕中的x坐标
         output wire [8:0] y
    //输出当前画笔在屏幕中的y坐标
       );

localparam HS_STA = 16,HS_END = 16 + 96,HA_STA = 16 + 96 + 48, VS_STA = 480 + 10,VS_END = 480 + 10 + 2,VA_END = 480,LINE = 800,SCREEN = 525;

reg [9:0] h_count;
reg [9:0] v_count;

assign hs = ~((h_count >= HS_STA) & (h_count < HS_END));
assign vs = ~((v_count >= VS_STA) & (v_count < VS_END));

assign x = (h_count < HA_STA) ? 0 : (h_count - HA_STA);
assign y = (v_count >= VA_END) ? (VA_END - 1) : (v_count);

assign active = ~((h_count < HA_STA) | (v_count > VA_END - 1));
assign animate = ((v_count == VA_END - 1) & (h_count == LINE));

always @ (posedge clk)
  begin
    if (rst)
      begin
        h_count <= 0;
        v_count <= 0;
      end
      if (clk_vga)  //绘制完一个像素点后，h_count,v_count加一
      begin
          if (h_count == LINE)  //一行绘制完成
          begin
            h_count <= 0;
            v_count <= v_count + 1;
          end
        else
          h_count <= h_count + 1;

          if (v_count == SCREEN)  //一帧绘制完成
          v_count <= 0;
      end
  end
endmodule
```

下面介绍游戏中的各个对象：

### meteorolite

陨石对象用element寄存器储存，储存结构如下：

| element[29:20] | element[19:11] | element[10:7]          | element[6:5]           | element[4:0]           |
| -------------- | -------------- | ---------------------- | ---------------------- | ---------------------- |
| 陨石当前x坐标  | 陨石当前y坐标  | 陨石当前x，y方向分速度 | 陨石朝向，一共四个方向 | 保留位置，用于功能拓展 |

```verilog
module meteorolite #(parameter initial_x=0,initial_y=0,seed = 12345678)(
    //seed为随机数种子，其实是计数器的rst_Target，整个随机为伪随机，但是由于陨石生成的
    //位置，速度，方向与游戏的进行总时间有关，所以可视为不可预测
         input clk,
         input clk_ram,
    //200MHz时钟，用于内存的读取，因为BRAM必须要时钟信号驱动，但是如果该时钟频率和其他时钟相同
    //则会造成1 tick的逻辑延时，因此需要提高BRAM时钟信号，从而使得程序其他部分可以视BRAM为一个
    //即时可读的储存器
         input [9:0]x,
    //当前画笔所在的x坐标
         input [8:0]y,
    //当前画笔所在的y坐标
         input en,
    //用于控制陨石是否启用，低电平时陨石不在屏幕上显示，高电平时陨石在屏幕上显示
         input meteorolite_type,
    //陨石的种类，一共一大一小两种，分别为0和1
         output color_on,
    //告诉上层模块，当前(x,y)位置是否有陨石颜色要输出
         output [11:0]color
    //当前位置该图层的颜色信息
       );
localparam character_W = 32,character_H = 32;
reg [29:0]element;
reg [12:0]addr;
    //内存地址的计算
reg [9:0]v_x;
    //x方向分速度
reg [9:0]v_y;
    //y方向分速度
wire v_x_add;
    //x方向增量，用于陨石的移动
wire v_y_add;
    //y方向增量，用于陨石的移动

initial
  begin
    element[29:20]=initial_x;//x
    element[19:11]=initial_y;//y
    element[10:7]=0;//rotation
    element[6:5]=0;//direction
    element[4:0]=0;//reserved
  end

    //三角函数的计算，用于控制陨石总运动速度
always@(*)
  begin
    case(element[10:7])
      0:
        begin
          v_x=100000;
          v_y=10000000;
        end
      1:
        begin
          v_x=102571;
          v_y=449395;
        end
      2:
        begin
          v_x=110991;
          v_y=230476;
        end
      3:
        begin
          v_x=127904;
          v_y=160387;
        end
      4:
        begin
          v_x=160387;
          v_y=127904;
        end
      5:
        begin
          v_x=230476;
          v_y=110991;
        end
      6:
        begin
          v_x=449395;
          v_y=102571;
        end
      7:
        begin
          v_x=10000000;
          v_y=100000;
        end
      default
      begin
        v_x=0;
        v_y=0;
      end
    endcase
  end
//BRAM储存器，存有陨石图片信息
sram #(.ADDR_WIDTH(13), .DATA_WIDTH(12), .DEPTH(8192), .MEMFILE("meteorolite.mem")) ram(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );
    
//陨石的动画控制，以及颜色地址的计算
reg [1:0]animation;
//该变量用于设置在内存中的偏移量，从而做出陨石转动的动画
    
//当画笔坐标在陨石当前的范围内时，计算该位置在内存中的地址，如果不在范围内，则地址为16'h0000
always @(posedge clk)//draw control
  begin
    if((x>=element[29:20]) & (x<(element[29:20]+character_W)) & (y>=element[19:11]) & (y<(element[19:11]+character_H)) & en)
      begin
        addr<=meteorolite_type * 4096+(y-element[19:11])*32+x-element[29:20]+animation * 1024;
      end
    else
      addr<=16'h0000;
  end

wire animation_ctrl;
//动画控制
always @(posedge animation_ctrl)
  begin
    animation<=animation+1;
  end

//使用蓝幕技术，当前内存中取得的颜色信息不为纯蓝色时为高电平，否则为低电平
//用于告诉图像引擎是否应该输出颜色
assign color_on = (color==12'h00f) ? 0 : 1;

wire [9:0]random_x;
wire [8:0]random_y;

wire [23:0]v_x_new;
wire [23:0]v_y_new;
wire [24:0]random_main;
wire [9:0]random_x_new;
wire [8:0]random_y_new;

    //陨石生成以及移动模块
always @(posedge clk)//random position
  begin
    if((element[29:20]>0) & ((element[29:20]+character_W)<640) & ((element[19:11]+character_H)<480) & (element[19:11]>0) & en)
      begin
        if(element[6:5]==2'b00)
          begin
            element[29:20]<=element[29:20]+v_x_add;
            element[19:11]<=element[19:11]+v_y_add;
          end
        else if(element[6:5]==2'b01)
          begin
            element[29:20]<=element[29:20]-v_x_add;
            element[19:11]<=element[19:11]-v_y_add;
          end
        else if(element[6:5]==2'b10)
          begin
            element[29:20]<=element[29:20]-v_x_add;
            element[19:11]<=element[19:11]+v_y_add;
          end
        else
          begin
            element[29:20]<=element[29:20]+v_x_add;
            element[19:11]<=element[19:11]-v_y_add;
          end
          //通过clk1和clk2的计数情况来控制陨石在的x，y方向的移动
      end
    else
      begin
        if(random_x[1:0]==2'b00)
          begin
            element[29:20]<=1;
            element[19:11]<=random_y+40;
            element[6:5]<={2{random_y[0]}};
          end
        else if(random_x[1:0]==2'b10)
          begin
            element[29:20]<=random_x+80;
            element[19:11]<=1;
            element[6:5]<={random_y[0],1'b0};
          end
        else if(random_x[1:0]==2'b01)
          begin
            element[29:20]<=random_x+80;
            element[19:11]<=480-character_H-1;
            element[6:5]<={random_y[0],1'b1};
          end
        else
          begin
            element[29:20]<=640-character_W-1;
            element[19:11]<=random_y+40;
            element[6:5]<={~random_y[0],random_y[0]};
          end
        element[10:7]<=random_main[2:0];
      end
    //通过random_y和random_x来生成随机方向的陨石
  end

assign v_x_new = v_x*4000;
assign v_y_new = v_y*4000;
assign random_x_new = random_main[9:0] & 500;
assign random_y_new = random_main[12:4] & 380;

    //控制陨石在x，y方向的分速度
clock clk1(
        .clk(clk),
        .rst(0),
        .rst_Target(v_x_new),
        .auto_rst(1),
        .clk_out(v_y_add)
      );
clock clk2(
        .clk(clk),
        .rst(0),
        .rst_Target(v_y_new),
        .auto_rst(1),
        .clk_out(v_x_add)
      );

    //伪随机生成时钟组，通过多个时钟回环嵌套,来生成随机的random_y和random_x
clock random_clk_y(
        .clk(clk),
        .rst(0),
        .rst_Target(random_y_new),
        .auto_rst(1),
        .counter(random_y)
      );

clock random_clk_x(
        .clk(clk),
        .rst(0),
        .rst_Target(random_x_new),
        .auto_rst(1),
        .counter(random_x)
      );

clock random_clk_main(
        .clk(clk),
        .rst(0),
        .rst_Target(seed),
        .auto_rst(1),
        .counter(random_main)
      );
    
//动画控制计数器，每隔0.5秒陨石旋转90度
clock anim(
        .clk(clk),
        .rst(0),
        .rst_Target(50000000),
        .auto_rst(1),
        .clk_out(animation_ctrl)
      );
endmodule
```

### Character

玩家对象用element寄存器储存，储存结构如下：

| element[29:20] | element[19:11] | element[10:7]          | element[6:2] | element[1:0]           |
| -------------- | -------------- | ---------------------- | ------------ | ---------------------- |
| 玩家当前x坐标  | 玩家当前y坐标  | 保留位置，用于功能拓展 | 玩家方向     | 保留位置，用于功能拓展 |

ctrl_bus用于控制玩家对象，各控制位功能

| ctrl_bus[6] | ctrl_bus[5] | ctrl_bus[4] | ctrl_bus[3] | ctrl_bus[2] | ctrl_bus[1] | ctrl_bus[0] |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| 发射子弹    | 逆时针旋转  | 顺时针旋转  | 上          | 下          | 左          | 右          |

```verilog
module character #(parameter initial_x=64,initial_y=400,MEMFILE = "ship1.mem" )(
         input clk,
         input clk_ram,
         input RST,
         input [9:0]x,
         input [8:0]y,
         input [6:0]ctrl_bus,
    //控制线
         output color_on,
    //告诉上层模块，当前(x,y)位置是否有颜色要输出
         output [11:0]color,
    //该图层(x,y)位置的颜色信息
         output reg fire_on,
    //1 tick脉冲，表示发射一发子弹
         output [9:0]pos_x,
         output [8:0]pos_y,
         output [4:0]rotate
    //告诉上层模块当前玩家所在位置，以及方向信息
       );
reg [29:0]element;
reg [15:0]addr;
reg [31:0]count;
reg fire_en;

wire pos_offset;
wire x_offset;
wire y_offset;
wire rotation_offset;
    
assign pos_x=element[29:20];
assign pos_y=element[19:11];
assign rotate=element[6:2];

localparam character_H=32,character_W=32 ;

initial
  begin
    element[29:20]=initial_x;//x
    element[19:11]=initial_y;//y
    element[10:7]=0;//reserved
    element[6:2]=0;//rotate
    element[1:0]=0;//reserved
    fire_en=1;
    fire_on=1;
  end
    
sram #(.ADDR_WIDTH(16), .DATA_WIDTH(12), .DEPTH(28672), .MEMFILE(MEMFILE)) ram(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );
//颜色信息的地址计算
always @(posedge clk)//draw control
  begin
    if((x>=element[29:20]) & (x<(element[29:20]+character_W)) & (y>=element[19:11]) & (y<(element[19:11]+character_H)))
      begin
        addr<=(element[3:2] * 7 + element[6:4]) * 1024+(y-element[19:11])*32+x-element[29:20];
      end
    else
      addr<=16'h0000;
  end

assign color_on = (color==12'h00f) ? 0 : 1;
/*****************************************************************************************************************************/
//volcity control
//一共28个方向，但一共可以简化为8个不同的速度分量
reg [31:0]v_x;
reg [31:0]v_y;
always@(*)
  begin
    case(element[6:4])
      0:
        begin
          v_y=100000;
          v_x=0;
        end
      1:
        begin
          v_y=102571;
          v_x=449395;
        end
      2:
        begin
          v_y=110991;
          v_x=230476;
        end
      3:
        begin
          v_y=127904;
          v_x=160387;
        end
      4:
        begin
          v_y=160387;
          v_x=127904;
        end
      5:
        begin
          v_y=230476;
          v_x=110991;
        end
      6:
        begin
          v_y=449395;
          v_x=102571;
        end
      7:
        begin
          v_y=0;
          v_x=100000;
        end
      default
      begin
        v_y=0;
        v_x=0;
      end
    endcase
  end
/*****************************************************************************************************************************/
//发射控制
//发射间隔为0.5s
//fire_en用于标识子弹装填，当fire_en为1时，子弹装填完成，可以发射
always @(posedge clk)
  begin
    if(ctrl_bus[6] & fire_en)
      begin
        count<=32'h00000000;
        fire_en<=0;
        fire_on<=1;
      end
    else
      begin
        if(count<50000000)//
          begin
            count<=count+1;
            //fire_on<=0;
          end
        else
          begin
            count<=count;
            fire_en<=1;
          end
        fire_on<=0;
      end
  end

/*****************************************************************************************************************************/
//animate control
//控制玩家图层飞船的位置和方向
always @(posedge clk)
  begin
    if(element[29:20]>32 && (element[29:20]+character_W)<640-32 && (element[19:11]+character_H<480-32) && element[19:11]>32)
      begin
          //上下左右的方向控制
        case(ctrl_bus[3:0])
          4'b0001:
            begin
              case(element[3:2])
                0:
                  begin
                    element[19:11]<=element[19:11]+x_offset;
                    element[29:20]<=element[29:20]+y_offset;
                  end
                1:
                  begin
                    element[19:11]<=element[19:11]+y_offset;
                    element[29:20]<=element[29:20]-x_offset;
                  end
                2:
                  begin
                    element[19:11]<=element[19:11]-x_offset;
                    element[29:20]<=element[29:20]-y_offset;
                  end
                3:
                  begin
                    element[19:11]<=element[19:11]-y_offset;
                    element[29:20]<=element[29:20]+x_offset;
                  end
              endcase
            end
          4'b0010:
            begin
              case(element[3:2])
                0:
                  begin
                    element[19:11]<=element[19:11]-x_offset;
                    element[29:20]<=element[29:20]-y_offset;
                  end
                1:
                  begin
                    element[19:11]<=element[19:11]-y_offset;
                    element[29:20]<=element[29:20]+x_offset;
                  end
                2:
                  begin
                    element[19:11]<=element[19:11]+x_offset;
                    element[29:20]<=element[29:20]+y_offset;
                  end
                3:
                  begin
                    element[19:11]<=element[19:11]+y_offset;
                    element[29:20]<=element[29:20]-x_offset;
                  end
              endcase
            end
          4'b1000:
            begin
              case(element[3:2])
                0:
                  begin
                    element[19:11]<=element[19:11]-y_offset;
                    element[29:20]<=element[29:20]+x_offset;
                  end
                1:
                  begin
                    element[19:11]<=element[19:11]+x_offset;
                    element[29:20]<=element[29:20]+y_offset;
                  end
                2:
                  begin
                    element[19:11]<=element[19:11]+y_offset;
                    element[29:20]<=element[29:20]-x_offset;
                  end
                3:
                  begin
                    element[19:11]<=element[19:11]-x_offset;
                    element[29:20]<=element[29:20]-y_offset;
                  end
              endcase
            end
          4'b0100:
            begin
              case(element[3:2])
                0:
                  begin
                    element[19:11]<=element[19:11]+y_offset;
                    element[29:20]<=element[29:20]-x_offset;
                  end
                1:
                  begin
                    element[19:11]<=element[19:11]-x_offset;
                    element[29:20]<=element[29:20]-y_offset;
                  end
                2:
                  begin
                    element[19:11]<=element[19:11]-y_offset;
                    element[29:20]<=element[29:20]+x_offset;
                  end
                3:
                  begin
                    element[19:11]<=element[19:11]+x_offset;
                    element[29:20]<=element[29:20]+y_offset;
                  end
              endcase
            end
          default:
            begin
              element[19:11]<=element[19:11];
              element[29:20]<=element[29:20];
            end
        endcase

          //旋转控制
        if(ctrl_bus[5:4]==2'b10)
          begin
            if(element[6:4]<7)
              element[6:4]<=element[6:4]-rotation_offset;
            else
              begin
                element[3:2]<=element[3:2] - 1;
                element[6:4]<=6;
              end
          end
        else if(ctrl_bus[5:4]==2'b01)
          begin
            if(element[6:4]<7)
              element[6:4]<=element[6:4]+rotation_offset;
            else
              begin
                element[3:2]<=element[3:2] + 1;
                element[6:4]<=0;
              end
          end
        else
          begin
            element[6:2]<=element[6:2];
          end
      end
      //防止飞船到达边界后卡住
    else if(element[29:20]==32 )//prevent edge condition
      element[29:20]<=element[29:20]+1;
    else if((element[29:20]+character_W)==640-32)
      element[29:20]<=element[29:20]-1;
    else if((element[19:11]+character_H)==480-32)
      element[19:11]<=element[19:11]-1;
    else if(element[19:11]==32)
      element[19:11]<=element[19:11]+1;
    else
      begin
        element[19:11]<=element[19:11];
        element[29:20]<=element[29:20];
      end
  end
/*****************************************************************************************************************************/
wire [31:0]v_x_new;
wire [31:0]v_y_new;
assign v_x_new = v_x*5;
assign v_y_new = v_y*5;

    //计时器组用于控制旋转速度和上下左右操作的速度
clock clk_x_offset(
        .clk(clk),
        .rst(~(|v_x_new)),
        .rst_Target(v_x_new),
        .auto_rst(1),
        .clk_out(x_offset)
      );

clock clk_y_offset(
        .clk(clk),
        .rst(~(|v_y_new)),
        .rst_Target(v_y_new),
        .auto_rst(1),
        .clk_out(y_offset)
      );

clock clk_rotation(
        .clk(clk),
        .rst(0),
        .rst_Target(6500000),
        .auto_rst(1),
        .clk_out(rotation_offset)
      );
endmodule

```

### fire

子弹对象用element寄存器储存，储存结构如下：

| element[29:20] | element[19:11] | element[10:6] | element[5:0]           |
| -------------- | -------------- | ------------- | ---------------------- |
| 子弹当前x坐标  | 子弹当前y坐标  | 子弹方向      | 保留位置，用于功能拓展 |

```verilog
module fire #(parameter initial_x=1,initial_y=1,type=0)(
         input clk,
         input rst,
         input clk_ram,
         input [9:0]x,
         input [8:0]y,
         input [9:0]pos_x,
         input [8:0]pos_y,
         input [4:0]rotation,
    //接收玩家飞船位置以及朝向
         input en,
    //控制该图层是否显示，en==1时，图层显示
         input direction,
    //判断当前飞船是否在前进
    //因为本游戏没有子弹来源的判定，只有子弹和玩家飞船图层重叠的判断
    //因此玩家自己的子弹也可对自己造成伤害
    //而子弹的显示逻辑是，当检测到玩家发射子弹信号时，子弹从玩家飞船所在位置射出，同时启动一个计时器
    //但此时子弹图层不显示，伤害判断模块不工作
    //当计时器计时完毕时，子弹图层显示，开始进行伤害判断，但由于飞船在前进的时候，和子弹相对速度
    //会变小，所以导致原先的计时器时间长度不够，子弹图层将与飞船图层重叠，对自己造成伤害
    //所以当飞船在前进的时候发射子弹，需要重新设置一个更长的计时器长度
         output color_on,
         output [11:0]color,
         output reg ready
    //当子弹运行到屏幕的显示区域之外的时候，给上层模块发送ready信号，表示该对象能重新被使用
       );
localparam character_W = 32,character_H = 32;
reg [29:0]element;
reg [12:0]addr;
reg [22:0]v_x;
reg [22:0]v_y;
wire v_x_add;
wire v_y_add;
wire visible;


initial
  begin
    element=0;
  end

always@(*)
  begin
    case(element[10:8])
      0:
        begin
          v_y=100000;
          v_x=0;
        end
      1:
        begin
          v_y=102571;
          v_x=449395;
        end
      2:
        begin
          v_y=110991;
          v_x=230476;
        end
      3:
        begin
          v_y=127904;
          v_x=160387;
        end
      4:
        begin
          v_y=160387;
          v_x=127904;
        end
      5:
        begin
          v_y=230476;
          v_x=110991;
        end
      6:
        begin
          v_y=449395;
          v_x=102571;
        end
      7:
        begin
          v_y=0;
          v_x=100000;
        end
      default
      begin
        v_y=0;
        v_x=0;
      end
    endcase
  end

sram #(.ADDR_WIDTH(13), .DATA_WIDTH(12), .DEPTH(8192), .MEMFILE("vga03_sprites.mem")) ram(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );

always @(posedge clk)//draw control
  begin
    if((x>=element[29:20]) & (x<=(element[29:20]+character_W-1)) & (y>=element[19:11]) & (y<=(element[19:11]+character_H)) & en & visible)
      begin
        addr<=160+(y-element[19:11])*256+x-element[29:20] + 32*type;
      end
    else
      addr<=16'h0000;
  end

assign color_on= ((color==12'h00f)) ? 0 : 1;
    
wire setpos;

always @(posedge clk)
  begin
      //接收到重置信号时，子弹位置被设置为发射子弹的飞船所在位置
    if(setpos)
      begin
        element[29:20]<=pos_x;
        element[19:11]<=pos_y;
        element[10:6]<=rotation;
        ready<=0;
      end
    else
      begin
        if((element[29:20]>0) & ((element[29:20]+character_W)<640) & ((element[19:11]+character_H)<480) & (element[19:11]>0))
          begin
            case(element[7:6])
              2'b00:
                begin
                  element[29:20]<=element[29:20]+v_x_add;
                  element[19:11]<=element[19:11]-v_y_add;
                end
              2'b01:
                begin
                  element[29:20]<=element[29:20]+v_y_add;
                  element[19:11]<=element[19:11]+v_x_add;
                end
              2'b10:
                begin
                  element[29:20]<=element[29:20]-v_x_add;
                  element[19:11]<=element[19:11]+v_y_add;
                end
              2'b11:
                begin
                  element[29:20]<=element[29:20]-v_y_add;
                  element[19:11]<=element[19:11]-v_x_add;
                end
            endcase
          end
        else
          begin
            element[29:20]<=element[29:20];
            element[19:11]<=element[19:11];
            ready<=1;
          end
      end
  end
    
//当上层模块发送rst信号时，在该部分产生一个1 tick的脉冲，用于重置对象位置，重置位置为飞船坐标
pulse_reverse #(.netnum(1)) pulsere(
                .clk(clk),
                .in(rst),
                .out(setpos)//one tick high signal
              );

wire [23:0]v_x_new;
wire [23:0]v_y_new;
wire [23:0]visible_rst;
assign visible_rst = direction ? 6000000 : 4000000;
    //为前进状态和其他状态分配不同的计时器计数数量
assign v_x_new = {v_x,1'b0};
assign v_y_new = {v_y,1'b0};

    //动画控制计时器组
clock anim_x(
        .clk(clk),
        .rst(~(|v_x_new)),
        .rst_Target(v_x_new),
        .auto_rst(1),
        .clk_out(v_x_add)
      );

clock anim_y(
        .clk(clk),
        .rst(~(|v_y_new)),
        .rst_Target(v_y_new),
        .auto_rst(1),
        .clk_out(v_y_add)
      );

    //用于控制子弹是否可见，当计数器计数未完成时，子弹处于不可见状态，防止对发射子弹的玩家
    //造成伤害
clock visi(
        .clk(clk),
        .rst(setpos),
        .rst_Target(visible_rst),
        .auto_rst(0),
        .clk_out(visible)
      );
endmodule
```

下面介绍游戏中的各个后台，以及控制模块

### 碰撞检测

damage储存器的储存情况如下：

| damage[2]                    | damage[1]                 | damage[0]                 |
| ---------------------------- | ------------------------- | ------------------------- |
| 当两架飞船同归于尽时为高电平 | 当飞船1受到伤害时为高电平 | 当飞船2受到伤害时为高电平 |

```verilog
module collision_detection (
         input clk,
         input [27:0]color_on,
    //low 2 bits from user the rest from fire,higest is background
         output [2:0]damage_pulse
       );
reg [2:0]damage;
    
initial
  damage=3'b000;
    
    //对damage的各个位进行赋值
always @(posedge clk)
  damage <= {color_on[1]&color_on[0],(|color_on[26:2])&color_on[1],(|color_on[26:2])&color_on[0]};

    //取时钟边沿，生成一个1 tick的脉冲发送给上层模块
reg [2:0]damage_r1;
reg [2:0]damage_r2;

always @(posedge clk)
  damage_r1 <= damage;
always @(posedge clk)
  damage_r2 <= damage_r1;
assign damage_pulse = damage_r1 & (~damage_r2);
endmodule
```

### HP计算及显示

```verilog
module score(
         input clk,
         input clk_ram,
         input rst,
         input [9:0]x,
         input [8:0]y,
         input [2:0]damage,
         input [2:0]state,
         output [11:0]color,
         output reg [1:0]over
       );
reg [3:0]HP1;
reg [3:0]HP2;
//储存两架飞船的血量，目前最高设置为8HP
reg [11:0]addr;

initial
  begin
    over=2'b00;
    HP1=8'h08;
    HP2=8'h08;
  end

always @(posedge clk or posedge rst)
  begin
    if(rst)//当游戏重新开始时，恢复HP至8
      begin
        HP1<=8;
        HP2<=8;
      end
    else if(state==3'b010)
        //为避免干扰，仅在游戏开始时计算HP的加减
      begin
        if((|HP1) & (|HP2))
          begin
            case(damage)
                //收到damage模块的脉冲，并重新计算两架飞船的HP
              3'b100:
                begin
                  HP1<=0;
                  HP2<=0;
                end
              3'b001:
                HP1<=HP1-1;
              3'b010:
                HP2<=HP2-1;
              default
              begin
                HP1<=HP1;
                HP2<=HP2;
              end
            endcase
          end
        else
          begin
            HP1<=HP1;
            HP2<=HP2;
          end
      end
    over<={|HP1,|HP2};
  end
/***********************************************************************************/
    //下面是HP显示部分
sram #(.ADDR_WIDTH(12), .DATA_WIDTH(12), .DEPTH(1280), .MEMFILE("font.mem")) background(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );


always @(posedge clk)
  begin
    if((y>=20) & (y<28))
      begin
        if((x>=64) & (x<104))
          addr <= 80+(y-20)*160+x-64;
        else if((x>=106) & (x<113))
          addr <= HP1 * 8 + (y-20) * 160 + x-106;
        else if((x>=164) & (x<204))
          addr <= 120 + (y-20) *160 + x-164;
        else if((x>=206) & (x<213))
          addr <= HP2 * 8 + (y-20) *160 + x-206;
        else
          addr<=9;
      end
    else
      begin
        addr<=9;
      end
  end

endmodule
```

### Initial Page

(注：该界面实际上是`initial page`和`start_page`共同的部分，但是当时给module取名叫了`start_page`)

```verilog
module start_page(
         input clk,
         input clk_ram,
         input rst,
         input [9:0]x,
         input [8:0]y,
         input [9:0]x_1,
         input [8:0]y_1,
         input [4:0]rotate_1,
         input [9:0]x_2,
         input [8:0]y_2,
         input [4:0]rotate_2,
    //获取两架飞船当前的朝向和位置信息
         input [2:0]state,
    //获取当前state情况
         output color_on,
         output [11:0]color,
         output reg [13:0]sys_ctrl,
    //系统控制线，用于接管用户控制以控制对象
         output reg done
    //当飞船位置回到预定地点，发送完成信号给上层模块
       );
reg [15:0]addr;
localparam xpos_1=140,ypos_1=240,xpos_2=480,ypos_2=240;

//颜色计算及输出
sram #(.ADDR_WIDTH(16), .DATA_WIDTH(12), .DEPTH(57280), .MEMFILE("start_page.mem")) start(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );

always @(posedge clk)
  begin
      if((state==3'b000 | state==3'b001) & (x>=160) & (x<480) & (y>=150) &(y<329))
      begin
        addr<=320*(y-150)+x-160;
      end
    else
      addr<=16'h0000;
  end

assign color_on = (color==12'h00f) ? 0 : 1;
    
    //当飞船位置回到预定地点，发送完成信号给上层模块
always @(posedge clk)
  done <= ((x_1==xpos_1) & (y_1==ypos_1) & (x_2==xpos_2) & (y_2==ypos_2) & (rotate_2==5'b00011) & (rotate_1==5'b00001));

initial
  begin
    sys_ctrl=14'h00000;
    done=1'b0;
  end

    //系统控制部分，状态机分为两个状态
    //state_1:控制飞船到达预定地点
    //state_2:控制飞船朝向预定方向
reg state_shift;
reg nextstate;
initial
  state_shift=1'b0;

always @(posedge clk or posedge rst)
  begin
    if(rst)
      state_shift<=1'b0;
    else
      state_shift<=nextstate;
  end

always @(*)
  begin
    if((state_shift==1'b0) & (x_1==xpos_1) & (y_1==ypos_1) & (x_2==xpos_2) & (y_2==ypos_2))
      nextstate=1'b1;
    else
      nextstate=state_shift;
  end

    //系统获得控制权后，对飞船模块发出控制信号，并同时监控飞船位置，直到飞船到达预定位置
always @(posedge clk)
  begin
    if(state_shift==0)
      begin
        if(x_1<xpos_1)
          begin
            if(rotate_1!=5'b00001)
              begin
                sys_ctrl[5]<=1;
                sys_ctrl[3]<=0;
              end
            else
              begin
                sys_ctrl[5]<=0;
                sys_ctrl[3]<=1;
              end
          end
        else if(x_1>xpos_1)
          begin
            if(rotate_1!=5'b00011)
              begin
                sys_ctrl[5]<=1;
                sys_ctrl[3]<=0;
              end
            else
              begin
                sys_ctrl[5]<=0;
                sys_ctrl[3]<=1;
              end
          end
        else if(y_1<ypos_1)
          begin
            if(rotate_1!=5'b00010)
              begin
                sys_ctrl[5]<=1;
                sys_ctrl[3]<=0;
              end
            else
              begin
                sys_ctrl[5]<=0;
                sys_ctrl[3]<=1;
              end
          end
        else if(y_1>ypos_1)
          begin
            if(rotate_1!=5'b00000)
              begin
                sys_ctrl[5]<=1;
                sys_ctrl[3]<=0;
              end
            else
              begin
                sys_ctrl[5]<=0;
                sys_ctrl[3]<=1;
              end
          end
        else
          begin
            sys_ctrl[5]<=0;
            sys_ctrl[3]<=0;
          end

        if(x_2<xpos_2)
          begin
            if(rotate_2!=5'b00001)
              begin
                sys_ctrl[12]<=1;
                sys_ctrl[10]<=0;
              end
            else
              begin
                sys_ctrl[12]<=0;
                sys_ctrl[10]<=1;
              end
          end
        else if(x_2>xpos_2)
          begin
            if(rotate_2!=5'b00011)
              begin
                sys_ctrl[12]<=1;
                sys_ctrl[10]<=0;
              end
            else
              begin
                sys_ctrl[12]<=0;
                sys_ctrl[10]<=1;
              end
          end
        else if(y_2<ypos_2)
          begin
            if(rotate_2!=5'b00010)
              begin
                sys_ctrl[12]<=1;
                sys_ctrl[10]<=0;
              end
            else
              begin
                sys_ctrl[12]<=0;
                sys_ctrl[10]<=1;
              end
          end
        else if(y_2>ypos_2)
          begin
            if(rotate_2!=5'b00000)
              begin
                sys_ctrl[12]<=1;
                sys_ctrl[10]<=0;
              end
            else
              begin
                sys_ctrl[12]<=0;
                sys_ctrl[10]<=1;
              end
          end
        else
          begin
            sys_ctrl[12]<=0;
            sys_ctrl[10]<=0;
          end
      end
    else
      begin
        if(rotate_2!=5'b00011)
          sys_ctrl[12]<=1;
        else
          sys_ctrl[12]<=0;

        if(rotate_1!=5'b00001)
          sys_ctrl[5]<=1;
        else
          sys_ctrl[5]<=0;

        sys_ctrl[10]<=0;
        sys_ctrl[3]<=0;
      end
  end
endmodule
```

### Final Page 1

```verilog
module final_page(
         input clk,
         input clk_ram,
         input rst,
         input [9:0]x,
         input [8:0]y,
    //获取画笔位置信息
         input [9:0]x_1,
         input [8:0]y_1,
         input [9:0]x_2,
         input [8:0]y_2,
    //获取两架飞船位置信息
         input [1:0]over,
    //获取当前获胜者信息
         input [2:0]state,
         input pulse,
    //1 tick per screen
         output reg color_on,
         output [11:0]color,
         output reg done
    //当黑框收缩结束时，发送完成信号给上层模块
       );
wire setpos;
reg flag;
reg [9:0]black_x_l;
reg [8:0]black_y_u;
reg [9:0]black_x_r;
reg [8:0]black_y_d;
reg [9:0]pos_x;
reg [8:0]pos_y;
initial
  begin
    flag=0;
    done=0;
  end

always@(posedge clk)
  begin
    flag<=((state==3'b101) | (state==3'b100));
    done<=((black_x_l == (pos_x-10)) & (black_x_r == (pos_x +42)) & (black_y_u == (pos_y - 10)) & (black_y_d == (pos_y + 42)));
  end

    //在设置信号到来的时候，设置最后黑框收缩的位置
always@(posedge setpos)
  begin
    pos_x<= (over==2'b01)? x_2:x_1;
    pos_y<= (over==2'b01)? y_2:y_1;
  end

    //当画笔位置到达黑框外部的时候，输出黑色，否则输出透明
always @(posedge clk_ram)
  begin
    if((x<black_x_l) | (y>black_y_d) | (x>black_x_r) | (y <black_y_u))
      color_on<=1;
    else
      color_on<=0;
  end

assign color = 12'h000;

    //黑框收缩动画效果
always @(posedge clk or posedge rst)
  begin
    if(setpos | rst)
      begin
        black_x_l<=32;
        black_x_r<=608;
        black_y_u<=32;
        black_y_d<=448;
      end
    else if(pulse & ((state==3'b101) | (state==3'b100)))
      begin
        if(black_x_l < (pos_x-10))
          begin
            black_x_l<=black_x_l + 1;
          end
        else
          begin
            black_x_l<=black_x_l;
          end

        if(black_x_r > (pos_x +42))
          begin
            black_x_r<=black_x_r - 1;
          end
        else
          begin
            black_x_r<=black_x_r;
          end

        if(black_y_u < (pos_y - 10))
          begin
            black_y_u<=black_y_u + 1;
          end
        else
          begin
            black_y_u<=black_y_u;
          end

        if(black_y_d > (pos_y + 42))
          begin
            black_y_d<=black_y_d - 1;
          end
        else
          begin
            black_y_d<=black_y_d;
          end
      end
    else
      ;
  end
    
//取信号边沿，产生1 tick脉冲，用于设置最后黑框收缩的范围
reg flag_r1;
reg flag_r2;
always @(posedge clk)
  flag_r1 <= flag;
always @(posedge clk)
  flag_r2 <= flag_r1;
assign setpos = flag_r1 & (~flag_r2);
endmodule
```

### Final Page 2

```verilog
//这个部分只有地址计算和图片显示部分，所以不做过多介绍
module final_page_2(
         input clk,
         input clk_ram,
         input [9:0]x,
         input [8:0]y,
         input [2:0]state,
         output color_on,
         output [11:0]color
       );
reg [15:0]addr;

sram #(.ADDR_WIDTH(16), .DATA_WIDTH(12), .DEPTH(14595), .MEMFILE("final_page_2.mem")) background(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color)
     );

always @(posedge clk)
  begin
    if((x>=111) & (x<528) &(y>=222) & (y<257) & (state==3'b011))
      addr<=x-111 + (y-222)*417;
    else
      addr<=16'h0000;
  end

assign color_on = (color == 12'h00f) ? 0 : 1;

endmodule
```

下面介绍游戏的主体控制部分

### Game Body

```verilog
module game_body(
         input CLK,
         input clk_ram,
         input clk_vga,
    //clk_vga时钟频率为25MHz主要因为图像引擎判断需要一定时间的延迟，100MHz会出现花屏
         input rst,
         input [9:0]x,
         input [8:0]y,
         input animate,
    //当一帧绘制完成时有1 tick高电平
         input [13:0]ctrl_bus_in,
    //玩家控制线
         input [2:0]state,
         output [1:0]over,
         output reg [11:0]RGB,
         output start_page_done,
         output final_page_done
       );
/******************************************************************************************************************/
//background
//背景图层，用于输出背景的颜色信息
reg [9:0]addr;
wire [11:0]color_background;
wire [11:0]color[27:0];
reg [4:0]background_offset;
reg v_background;
wire [13:0]sys_ctrl;
wire [13:0]ctrl_bus;

assign ctrl_bus = (state==3'b001) ?  sys_ctrl : ctrl_bus_in;

sram #(.ADDR_WIDTH(10), .DATA_WIDTH(12), .DEPTH(1024), .MEMFILE("background.mem")) background(
       .i_clk(clk_ram),
       .i_addr(addr),
       .i_write(0),
       .i_data(0),
       .o_data(color[27])
     );

always @(posedge CLK)
  begin
    addr <= {y[4:0],x[4:0]+background_offset};
  end

always @(posedge animate)
  begin
    v_background<=v_background+1;
  end

always @(posedge v_background)
  begin
    background_offset<=background_offset+1;
  end

/******************************************************************************************************************/
//character control
//飞船控制
//例化了两架飞船，代表两个玩家
wire [27:0]color_on;
wire color_on_final;
wire [11:0]color_final;
wire color_on_start;
wire [11:0]color_start;
wire color_on_final_page_2;
wire [11:0]color_final_page_2;
wire fire_on1;
wire fire_on2;
wire [9:0]pos_x_1;
wire [8:0]pos_y_1;
wire [9:0]pos_x_2;
wire [8:0]pos_y_2;
wire [4:0]rotate_1;
wire [4:0]rotate_2;
wire direction1;
wire direction2;
assign direction1 = (ctrl_bus[3] & ~ctrl_bus[2]) ? 1'b1 : 1'b0;
assign direction2 = (ctrl_bus[10] & ~ctrl_bus[9]) ? 1'b1 : 1'b0;

character #(.initial_x(360),.initial_y(240)) character1(
            .clk(CLK),
            .clk_ram(clk_ram),
            .RST(rst),
            .x(x),
            .y(y),
            .ctrl_bus(ctrl_bus[6:0]),
            .color_on(color_on[0]),
            .color(color[0]),
            .fire_on(fire_on1),
            .pos_x(pos_x_1),
            .pos_y(pos_y_1),
            .rotate(rotate_1)
            //            .fire_type(fire_type)
          );

character #(.initial_x(120),.initial_y(240),.MEMFILE("ship2.mem"))character2(
            .clk(CLK),
            .clk_ram(clk_ram),
            .RST(rst),
            .x(x),
            .y(y),
            .ctrl_bus(ctrl_bus[13:7]),
            .color_on(color_on[1]),
            .color(color[1]),
            .fire_on(fire_on2),
            .pos_x(pos_x_2),
            .pos_y(pos_y_2),
            .rotate(rotate_2)
            //            .fire_type(fire_type2)
          );


/************************************************************************************************************************/
//陨石控制，一共例化八颗陨石
reg [25:0]en;
//en用于启用陨石、子弹图层
    
meteorolite  #(.seed(234567))meteorolite1(
               .clk(CLK),
               .clk_ram(clk_ram),
               .x(x),
               .y(y),
               .en(en[2]),
               .meteorolite_type(0),
               .color_on(color_on[2]),
               .color(color[2])
             );

meteorolite #(.seed(124569))meteorolite2(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[3]),
              .meteorolite_type(1),
              .color_on(color_on[3]),
              .color(color[3])
            );

meteorolite #(.seed(274567))meteorolite3(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[4]),
              .meteorolite_type(1),
              .color_on(color_on[4]),
              .color(color[4])
            );

meteorolite #(.seed(134567))meteorolite4(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[5]),
              .meteorolite_type(0),
              .color_on(color_on[5]),
              .color(color[5])
            );

meteorolite #(.seed(434567))meteorolite5(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[6]),
              .meteorolite_type(1),
              .color_on(color_on[6]),
              .color(color[6])
            );

meteorolite #(.seed(934567))meteorolite6(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[7]),
              .meteorolite_type(1),
              .color_on(color_on[7]),
              .color(color[7])
            );

meteorolite #(.seed(1834567))meteorolite7(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[8]),
              .meteorolite_type(1),
              .color_on(color_on[8]),
              .color(color[8])
            );

meteorolite #(.seed(114567))meteorolite8(
              .clk(CLK),
              .clk_ram(clk_ram),
              .x(x),
              .y(y),
              .en(en[9]),
              .meteorolite_type(1),
              .color_on(color_on[9]),
              .color(color[9])
            );
/************************************************************************************************************************/
//fire control
//子弹控制，一共例化八颗子弹，其中玩家1有四颗，玩家2四颗
wire [11:0]fire_ready;
reg [7:0]rst_pos;
//rst_pos用于重新设置子弹位置，由下面的随机生成器生成
fire fire1(
       .clk(CLK),
       .rst(rst_pos[0]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_1),
       .pos_y(pos_y_1),
       .rotation(rotate_1),
       .en(en[10]),
       .direction(direction1),
       .color_on(color_on[10]),
       .color(color[10]),
       .ready(fire_ready[0])
     );
fire fire2(
       .clk(CLK),
       .rst(rst_pos[1]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_1),
       .pos_y(pos_y_1),
       .rotation(rotate_1),
       .en(en[11]),
       .direction(direction1),
       .color_on(color_on[11]),
       .color(color[11]),
       .ready(fire_ready[1])
     );
fire fire3(
       .clk(CLK),
       .rst(rst_pos[2]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_1),
       .pos_y(pos_y_1),
       .rotation(rotate_1),
       .en(en[12]),
       .direction(direction1),
       .color_on(color_on[12]),
       .color(color[12]),
       .ready(fire_ready[2])
     );
fire fire4(
       .clk(CLK),
       .rst(rst_pos[3]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_1),
       .pos_y(pos_y_1),
       .rotation(rotate_1),
       .en(en[13]),
       .direction(direction1),
       .color_on(color_on[13]),
       .color(color[13]),
       .ready(fire_ready[3])
     );

fire #(.type(1))fire5(
       .clk(CLK),
       .rst(rst_pos[4]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_2),
       .pos_y(pos_y_2),
       .rotation(rotate_2),
       .en(en[14]),
       .direction(direction2),
       .color_on(color_on[14]),
       .color(color[14]),
       .ready(fire_ready[4])
     );
fire #(.type(1))fire6(
       .clk(CLK),
       .rst(rst_pos[5]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_2),
       .pos_y(pos_y_2),
       .rotation(rotate_2),
       .en(en[15]),
       .direction(direction2),
       .color_on(color_on[15]),
       .color(color[15]),
       .ready(fire_ready[5])
     );
fire #(.type(1))fire7(
       .clk(CLK),
       .rst(rst_pos[6]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_2),
       .pos_y(pos_y_2),
       .rotation(rotate_2),
       .en(en[16]),
       .direction(direction2),
       .color_on(color_on[16]),
       .color(color[16]),
       .ready(fire_ready[6])
     );
fire #(.type(1))fire8(
       .clk(CLK),
       .rst(rst_pos[7]),
       .clk_ram(clk_ram),
       .x(x),
       .y(y),
       .pos_x(pos_x_2),
       .pos_y(pos_y_2),
       .rotation(rotate_2),
       .en(en[17]),
       .direction(direction2),
       .color_on(color_on[17]),
       .color(color[17]),
       .ready(fire_ready[7])
     );
/************************************************************************************************************************/
//collision detection
//碰撞检测
wire [2:0]damage;

collision_detection (
    .clk(CLK),
    .color_on(color_on),//low 2 bits from user the rest from fire
    .damage_pulse(damage)
  );

/************************************************************************************************************************/
//HP calc
//HP计算
wire [11:0]color_score;
score HP(
        .clk(CLK),
        .clk_ram(clk_ram),
        .rst(rst),
        .x(x),
        .y(y),
        .damage(damage),
        .state(state),
        .color(color_score),
        .over(over)
      );
/************************************************************************************************************************/
//draw control
//图像引擎，通过优先译码器来控制图层的重叠
always @(posedge clk_vga)
  begin
    if(y<=32)
      RGB<=color_score;
    else
      begin
        if(x>32 & (x<640-32) & (y<480-32))
          begin
            if(color_on_final_page_2)
              RGB<=color_final_page_2;
            else if(color_on_start)
              RGB<=color_start;
            else if(color_on_final)
              RGB<=color_final;
            else if(color_on[0])
              RGB<=color[0];
            else if(color_on[1])
              RGB<=color[1];
            else if(color_on[2])
              RGB<=color[2];
            else if(color_on[3])
              RGB<=color[3];
            else if(color_on[4])
              RGB<=color[4];
            else if(color_on[5])
              RGB<=color[5];
            else if(color_on[6])
              RGB<=color[6];
            else if(color_on[7])
              RGB<=color[7];
            else if(color_on[8])
              RGB<=color[8];
            else if(color_on[9])
              RGB<=color[9];
            else if(color_on[10])
              RGB<=color[10];
            else if(color_on[11])
              RGB<=color[11];
            else if(color_on[12])
              RGB<=color[12];
            else if(color_on[13])
              RGB<=color[13];
            else if(color_on[14])
              RGB<=color[14];
            else if(color_on[15])
              RGB<=color[15];
            else if(color_on[16])
              RGB<=color[16];
            else if(color_on[17])
              RGB<=color[17];
            else
              RGB<=color[27];
          end
        else
          RGB<=12'h000;
      end
  end
// end

/************************************************************************************************************************/
//main_control
wire damageflag;
wire enemy_create;
assign damageflag=|damage;
wire [31:0]enemy_rst_Target;


always @(posedge CLK)
  begin
      //伤害控制，当子弹或陨石对玩家造成伤害时，自动将子弹图层启用关闭
    if(fire_on1 & ~damageflag)
      begin
        if(fire_ready[0])
          begin
            en[10]<=1;
            rst_pos[0]<=~rst_pos[0];
          end
        else if(fire_ready[1])
          begin
            en[11]<=1;
            rst_pos[1]<=~rst_pos[1];
          end
        else if(fire_ready[2])
          begin
            en[12]<=1;
            rst_pos[2]<=~rst_pos[2];
          end
        else if(fire_ready[3])
          begin
            en[13]<=1;
            rst_pos[3]<=~rst_pos[3];
          end
        else
          ;
      end
    else if(~fire_on1 & damageflag)
      begin
        if(color_on[10])
          en[10]<=0;
        if(color_on[11])
          en[11]<=0;
        if(color_on[12])
          en[12]<=0;
        if(color_on[13])
          en[13]<=0;
        else
          ;
      end

    if(fire_on2 & ~damageflag)
      begin
        if(fire_ready[4])
          begin
            en[14]<=1;
            rst_pos[4]<=~rst_pos[4];
          end
        else if(fire_ready[5])
          begin
            en[15]<=1;
            rst_pos[5]<=~rst_pos[5];
          end
        else if(fire_ready[6])
          begin
            en[16]<=1;
            rst_pos[6]<=~rst_pos[6];
          end
        else if(fire_ready[7])
          begin
            en[17]<=1;
            rst_pos[7]<=~rst_pos[7];
          end
        else
          ;
      end
    else if(~fire_on2 & damageflag)
      begin
        if(color_on[14])
          en[14]<=0;
        if(color_on[15])
          en[15]<=0;
        if(color_on[16])
          en[16]<=0;
        if(color_on[17])
          en[17]<=0;
        else
          ;
      end
	//陨石生成及消失控制，当随机数生成器计时结束时，重新生成陨石
    //当陨石对玩家造成伤害时，陨石消失
    if((enemy_rst_Target[2:0]==0) & ~damageflag)
      en[2]<=1;
    else if(damageflag & color_on[2])
      en[2]<=0;
    if((enemy_rst_Target[2:0]==1) & ~damageflag)
      en[3]<=1;
    else if(damageflag & color_on[3])
      en[3]<=0;
    if((enemy_rst_Target[2:0]==2) & ~damageflag)
      en[4]<=1;
    else if(damageflag & color_on[4])
      en[4]<=0;
    if((enemy_rst_Target[2:0]==3) & ~damageflag)
      en[5]<=1;
    else if(damageflag & color_on[5])
      en[5]<=0;
    if((enemy_rst_Target[2:0]==4) & ~damageflag)
      en[6]<=1;
    else if(damageflag & color_on[6])
      en[6]<=0;
    if((enemy_rst_Target[2:0]==5) & ~damageflag)
      en[7]<=1;
    else if(damageflag & color_on[7])
      en[7]<=0;
    if((enemy_rst_Target[2:0]==6) & ~damageflag)
      en[8]<=1;
    else if(damageflag & color_on[8])
      en[8]<=0;
    if((enemy_rst_Target[2:0]==7) & ~damageflag)
      en[9]<=1;
    else if(damageflag & color_on[9])
      en[9]<=0;
  end
//用于设置陨石的生成
assign enemy_rst_Target = pos_x_1+pos_y_1++pos_y_2+pos_y_2+1234567;

clock clock1(
        .clk(CLK),
        .rst_Target(enemy_rst_Target),
        .auto_rst(1),
        .clk_out(enemy_create)
      );

start_page start(
             .clk(CLK),
             .clk_ram(clk_ram),
             .rst(rst),
             .x(x),
             .y(y),
             .x_1(pos_x_1),
             .y_1(pos_y_1),
             .rotate_1(rotate_1),
             .x_2(pos_x_2),
             .y_2(pos_y_2),
             .rotate_2(rotate_2),
             .state(state),
             .color_on(color_on_start),
             .color(color_start),
             .sys_ctrl(sys_ctrl),
             .done(start_page_done)
           );

final_page final(
             .clk(CLK),
             .clk_ram(clk_ram),
             .rst(rst),
             .x(x),
             .y(y),
             .x_1(pos_x_1),
             .y_1(pos_y_1),
             .x_2(pos_x_2),
             .y_2(pos_y_2),
             .over(over),
             .state(state),
             .pulse(animate),//1 tick per screen
             .color_on(color_on_final),
             .color(color_final),
             .done(final_page_done)
           );

final_page_2 final_2(
               .clk(CLK),
               .clk_ram(clk_ram),
               .x(x),
               .y(y),
               .state(state),
               .color_on(color_on_final_page_2),
               .color(color_final_page_2)
             );

endmodule
```

下面介绍游戏的辅助模块:

### 抖动消除

```verilog
module jitter_clr(clk, button,button_clean );
input clk;
input button;
output button_clean;
reg [19:0] cnt;

always @(posedge clk)
  begin
    if(button==1'b0)
      cnt <= 20'h00000;
    else if(cnt<20'h80000)
      cnt <= cnt + 1'b1;
  end
assign button_clean = cnt[19];
endmodule
```
